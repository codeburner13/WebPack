import Sigma from 'sigma';

import {
  mapChunks,
  mapModulesIdent,
  mapModulesUid,
} from 'format-data';

import {
  blue,
  greenRed,
} from 'percentageToColor';

import stats from 'data.json';

import('sigma/build/plugins/sigma.layout.forceAtlas2.min');

const element = document.getElementById('sigma-modules');
const nodes = [];
const edges = [];
const moduleCount = stats.modules.length;

let activeModuleUid = null;
let maxTimestamp = 0;
let maxSize = 0;

stats.modules.forEach(module => {
  if (module.size > maxSize) {
    maxSize = module.size;
  }

  if (module.timestamp > maxTimestamp) {
    maxTimestamp = module.timestamp;
  }
});

stats.modules.forEach((module, idx) => {
  const color = greenRed(Math.pow((module.size + 1) / (maxSize + 1), 1 / 4)); // eslint-disable-line no-restricted-properties, max-len
  const done = {};

  const uniqueReasons = module.reasons.filter(reason => {
    const parent = reason.module;
    if (done[`$${parent}`]) return false;
    done[`$${parent}`] = true;
    return true;
  });
  const { uid } = module;

  nodes.push({
    id: `module${uid}`,
    uid,
    moduleUid: uid,
    moduleId: module.id,
    module,
    type: 'webpack',
    size: module.size + 1,
    label: `[${module.id}] ${module.name}`,
    shortLabel: String(module.id),
    x: Math.cos(idx / moduleCount * Math.PI * 2) * Math.sqrt(uniqueReasons.length + 1) * Math.sqrt(moduleCount), // eslint-disable-line no-mixed-operators, max-len
    y: Math.sin(idx / moduleCount * Math.PI * 2) * Math.sqrt(uniqueReasons.length + 1) * Math.sqrt(moduleCount), // eslint-disable-line no-mixed-operators, max-len
    originalColor: color,
    color,
  });

  const edgeColor = typeof module.timestamp === 'number' ? blue(module.timestamp / maxTimestamp) : undefined;

  uniqueReasons.forEach(reason => {
    const parentIdent = reason.moduleIdentifier;
    const parentModule = mapModulesIdent[`$${parentIdent}`];

    if (!parentModule) return;

    const weight = 1 / uniqueReasons.length / uniqueReasons.length;

    const async = !module.chunks.some(chunk => { // eslint-disable-line arrow-body-style
      return (function isInChunks(chunks, checked) {
        if (!chunks.length) return false;
        if (chunks.indexOf(chunk) >= 0) return true;
        chunks = chunks.filter(c => !checked.includes(c));
        if (!chunks.length) return false;
        return chunks.some(c => isInChunks(mapChunks[c].parents, checked.concat(c)));
      }(parentModule.chunks, []));
    });

    edges.push({
      id: `edge${module.uid}-${parentModule.uid}`,
      sourceModuleUid: parentModule.uid,
      sourceModule: parentModule,
      source: `module${parentModule.uid}`,
      targetModule: module,
      targetModuleUid: module.uid,
      target: `module${module.uid}`,
      arrow: 'target',
      type: async ? 'dashedArrow' : 'arrow',
      lineDash: module.chunks.length === 0 ? [2] : [5],
      originalColor: edgeColor,
      color: edgeColor,
      size: weight,
      weight: async ? weight / 4 : weight,
    });
  });
});

const s = new Sigma({
  graph: {
    edges,
    nodes,
  },
  renderer: {
    type: 'canvas',
    container: element,
  },
  settings: {
    edgeColor: 'target',
    maxNodeSize: 4,
    minNodeSize: 4,
    maxEdgeSize: 2,
    minEdgeSize: 0.05,
  },
});

s.bind('clickNode', e => {
  if (e.data.node.moduleUid === activeModuleUid) {
    window.location.hash = '#modules';
  }
  else {
    window.location.hash = `#module/${e.data.node.moduleUid}`;
  }
});

s.refresh();

export const hideModuleGraph = () => {
  element.style.display = 'none';
  s.stopForceAtlas2();
};

export const showModuleGraph = () => {
  element.style.display = 'block';
  s.refresh();
  s.startForceAtlas2();
  s.renderers[0].resize();
};

export const setNormal = () => {
  activeModuleUid = null;
  s.graph.nodes().forEach(n => {
    n.color = n.originalColor;
    n.active = false;
  });
  s.graph.edges().forEach(e => {
    e.color = e.originalColor;
  });
  s.refresh();
};

export const setActiveModule = activeModule => {
  activeModuleUid = activeModule;
  const colors = {};

  const m = mapModulesUid[activeModule];
  m.reasons.forEach(r => {
    colors[r.moduleUid] = '#ff0000';
  });
  m.dependencies.forEach(d => {
    colors[d.moduleUid] = '#00aa00';
  });

  colors[activeModule] = '#000000';

  s.graph.nodes().forEach(n => {
    n.color = colors[n.moduleUid] || '#aaaaaa';
  });
  s.graph.edges().forEach(e => {
    if (e.targetModuleUid === activeModule) {
      e.color = '#ff0000';
    }
    else if (e.sourceModuleUid === activeModule) {
      e.color = '#00aa00';
    }
    else {
      e.color = '#aaaaaa';
    }
  });
  s.refresh();
};

export const setActiveChunk = activeChunk => {
  activeModuleUid = null;

  s.graph.nodes().forEach(n => {
    const m = n.module;
    n.color = m.chunks.includes(activeChunk) ? '#000000' : '#aaaaaa';
    n.active = false;
  });

  s.graph.edges().forEach(e => {
    const sm = e.sourceModule;
    const tm = e.targetModule;
    const sc = sm.chunks.includes(activeChunk);
    const tc = tm.chunks.includes(activeChunk);

    if (sc && tc) {
      e.color = '#000000';
    }
    else if (sc) {
      e.color = '#00aa00';
    }
    else if (tc) {
      e.color = '#ff0000';
    }
    else {
      e.color = '#aaaaaa';
    }
  });

  s.refresh();
};
